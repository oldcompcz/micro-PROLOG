simtrace-mod(is-trace all-trace)("y" n s f Parse-of-ConjC APPEND Parse-of-SS : "FIND:" Parse-of-Cond dict q #)
((count 1))
((update X Y)
  (DELCL ((value X Z)))
  (ADDCL ((value X (Y|Z)))))
((init X Y)
  (VAR X)
  (DELCL ((count X)))
  (SUM X 1 Z)
  (ADDCL ((count Z)))
  (ADDCL ((value X Y))))
((isall X Y Z|x)
  (init y ())
  (FORALL ((?? (1|X) x z)|z) ((PP found answer Z to X) (update y Z)))
  (DELCL ((value y Y))))
((response X)
  (P " trace?(y/n) ")
  (R X))
((test X (# Y Z))
  /
  (response x)
  (IF (EQ x "y") ((PP evaluating expressions using relations ..) (?? (1|X) Z y) / (Parse-of-SS Y z ()) (PP evaluating X :|z) (IF (SYS Y) (Y) ((ENTER X "y" Y)))) ((# Y Z))))
((test X (FORALL Y Z))
  /
  (response x)
  (IF (EQ x "y") ((APPEND Y ((NOT ? Z)) y) (effect (Parse-of-ConjC (?) y (?|z)) (PP trying to solve its negation :|z)) (IF (?? (1|X) y ()) ((PP negation of X solved so ..) FAIL) ((PP negation of X failed so ..)))) ((FORALL Y Z))))
((test X (ISALL Y Z|x))
  /
  (response y)
  (IF (EQ y "y") ((effect (Parse-of-ConjC (?) x (?|z)) (PP finding all Z such that :|z)) (isall X Y Z|x)) ((ISALL Y Z|x))))
((test X (NOT ? Y))
  /
  (response Z)
  (IF (EQ Z "y") ((PP X unnegated) (IF (?? (1|X) Y ()) ((PP unnegated X solved so ..) FAIL) ((PP unnegated X failed so ..)))) ((NOT ? Y))))
((test X (NOT|Y))
  /
  (response Z)
  (IF (EQ Z "y") ((PP X unnegated) (IF (?? (1|X) (Y) ()) ((PP unnegated X solved so ..) FAIL) ((PP unnegated X failed so ..)))) ((NOT|Y))))
((test X (OR Y Z))
  /
  (response x)
  (IF (EQ x "y") ((OR ((PP X either branch) (?? (1|X) Y y)|y) ((PP X or branch) (?? (1|X) Z y)))) ((OR Y Z))))
((test X (Y|Z))
  (CL ((dict Y)))
  /
  (P " trace?")
  (R x)
  (ENTER X x (Y|Z)))
((test X Y)
  (PP)
  Y
  (OR () ((NOT SYS Y) (PP retrying X) FAIL)))
((whichex X Y)
  (?? (1) Y Z)
  (IF (EQ Z ()) ((P|X) (PP) (PP backtracking ..) FAIL) ((PP No (more) answers))))
((whichex X Y)
  (PP No (more) answers))
((?? X () ()))
((?? X ((? Y)) ())
  /
  (?? X Y Z))
((?? (X|Y) (Z|x) y)
  (effect (Parse-of-Cond Z z ()) (P (X|Y) :|z))
  (test (X|Y) Z)
  (EQ Z (X1|Y1))
  (OR ((EQ X1 #) / (EQ Y1 (Z1 x1)) (Parse-of-Cond Z1 z ())) ((Parse-of-Cond Z z ())))
  (PP (X|Y) solved :|z)
  (SUM X 1 y1)
  (?? (y1|Y) x y))
((?? X ((/)|Y) (/ FAIL))
  /)
((?? X (Y|Z) x)
  (Parse-of-Cond Y y ())
  (PP X failing :|y)
  FAIL)
((effect|X)
  (? X)
  FAIL)
((effect|X))
((ENTER X "y" (Y|Z))
  /
  (CL ((Y|x)|y) 1 z)
  (Parse-of-SS (Y|Z) X1 ())
  (Parse-of-SS (Y|x) Y1 ())
  (APPEND (matching X :|X1) (with head of z :|Y1) Z1)
  (PP|Z1)
  (IF (EQ Z x) ((P "  match succeeds: ") (PP|X1)) ((P "  match fails") (PP) FAIL))
  (effect (NOT EQ y ()) (Parse-of-ConjC (?) y (?|x1)) (PP new query :|x1))
  (OR () ((PP retrying X) FAIL))
  (?? (1|X) y y1)|y1)
((ENTER X n Y)
  /
  Y
  (OR () ((PP retrying X) FAIL)))
((ENTER X s Y)
  /)
((ENTER X f Y)
  /
  FAIL)
((ENTER X q Y)
  ABORT)
((ENTER X Y Z)
  (P ENTER "y" n s (to succeed) f (to fail) or q (to quit))
  (R x)
  (ENTER X x Z))
((COPYRIGHT 1983 LPA LTD (V 6 -7)))
((is-trace X)
  (Parse-of-ConjC (?) Y (?|X))
  (IF (?? (1) Y ()) ((PP Yes)) ((PP No))))
((all-trace X)
  ("FIND:" X Y Z which-trace)
  (Parse-of-ConjC (:) x Z)
  (whichex Y x))
CLMOD
